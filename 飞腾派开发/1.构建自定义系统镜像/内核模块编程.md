# 内核模块编程

> 内核模块编程，就是编写内核C源代码生成自定义.ko文件:
>
> 参考： [2.1-理论-Linux驱动基础.pdf](.assets/2.1-理论-Linux驱动基础.pdf) 



下面以编写一个hello模块为例：

## 选择编译方式

### 交叉编译

使用与编译内核时的交叉工具链版本：

- **手动下载配置：**

  保证**交叉工具链**与**编译内核时的交叉工具链**一致：

  <u>不一致会导致很多编译问题：如命令行或函数调用名无法识别等各种错误</u>

  > 由于编译OS时采用的是 [编译内核.md](编译内核.md) 中`OS源码内修改内核配置编译`的方式，以这种方式生成的内核源代码及配置位于克隆OS文件夹`phytium-pi-os`目录下的`output/build/linux-custom`文件夹内，因此我们来到此目录查看`.config`文件：![image-20240123093023073](./%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BC%96%E7%A8%8B.assets/image-20240123093023073.png)
  >
  > 此即为编译内核时使用的交叉工具链。

  这里使用[ARM官方网站](https://developer.arm.com/downloads/-/gnu-a/10-2-2020-11)下的`aarch64_be-none-linux-gnu`编译工具链：![image-20240122162316630](./%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BC%96%E7%A8%8B.assets/image-20240122162316630.png)

  交叉编译工具链的配置参考： [交叉编译环境的构建.md](交叉编译环境的构建.md) 

  此编译链需要在`.bashrc`以及`.profile`中配置如下：

  ```bash
  export PATH=/opt/toolchains/gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu/bin:$PATH
  export ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu-
  export CC=aarch64-none-linux-gnu-gcc
  ```

- **利用编译内核时给出的工具链环境：**

  参考： [Phytium_Pi_OS.md](.assets/Phytium_Pi_OS.md) 中`系统支持linux-headers`章节内容：

  > #### 交叉编译内核模块
  >
  > 编译`phytiumpi_xxx_defconfig`，会在`output/target/usr/src`目录中安装linux-headers-version。
  > 使用工具链来交叉编译内核模块，工具链位于`output/host/bin`，工具链的sysroot为 `output/host/aarch64-buildroot-linux-gnu/sysroot`。
  >
  > 交叉编译内核外部模块的命令为：
  >
  > ```
  > $ make ARCH=arm64 \
  > CROSS_COMPILE=/home/xxx/phytium-pi-os/output/host/bin/aarch64-none-linux-gnu- \
  > -C /home/xxx/phytium-pi-os/output/target/usr/src/linux-headers-5.10.153-phytium-embeded \
  > M=$PWD \
  > modules
  > ```



### 系统内编译

参考： [Phytium_Pi_OS.md](.assets/Phytium_Pi_OS.md) 中`系统支持linux-headers`章节内容：

> ####  开发板上编译内核模块
>
> 编译完成后，linux-headers-version被安装在根文件系统的`/usr/src`目录下， 并为它创建了一个软链接`/lib/modules/version/build`。
> 注意，由于linux-headers是在x86-64主机交叉编译生成的，在开发板上直接使用它编译内核模块会报错：
> `/bin/sh: 1: scripts/basic/fixdep: Exec format error`。
> 因此，需要将x86-64格式的fixdep等文件替换为ARM aarch64格式的（以linux 5.10内核为例）：
> （1）`scp -r username@host:/home/xxx/phytium-pi-os/board/phytium/common/linux-5.10/scripts /usr/src/linux-headers-5.10.153-phytium-embeded`
> （2）或者在编译phytiumpi_xxx_defconfig之前，将board/phytium/common/post-custom-skeleton-debian-base-11.sh中的如下两行取消注释，再执行编译。
> `# cp -r board/phytium/common/linux-5.10/scripts $destdir`
> `# cp -r board/phytium/common/linux-4.19/scripts $destdir`
>
> 在开发板上编译内核外部模块的命令为：
> `make -C /lib/modules/5.10.153-phytium-embeded/build M=$PWD modules`

- 将源码`phytium-pi-os`目录下的`/board/phytium/common/linux-5.10/scripts`内容添加到开发板OS的`/usr/src/linux-headers-5.10.153-phytium-embeded/scripts`目录内，即执行：

  ```shell
  cp -r username@host:/home/xxx/phytium-pi-os/board/phytium/common/linux-5.10/scripts /usr/src/linux-headers-5.10.153-phytium-embeded
  ```



### 编写Makefile

参考 [2.1-理论-Linux驱动基础.pdf](.assets/2.1-理论-Linux驱动基础.pdf) **第三章：《Linux 内核模块编程》**

以下给出Makefile的内容：

Makefile：

- `obj-m`参数：`obj-m := file.o` 表示编译连接后将生成file.ko 模块

- `KDIR`参数：是内核Kbuild Makefile 所在路径。

  Linux 系统使用Kbuild Makefile 来编译内核或模块。

- `all`参数、`clean`参数：

  - -C 指定内核Kbuild Makefile 所在路径。
  - M=指定模块所在路径。

注：`xxx`=`zrz/Project`

```makefile
obj-m := hello.o

# 系统内编译
KDIR := /lib/modules/$(shell uname -r)/build

# The following lines are considered as comments because the condition is always false
ifeq (0,1)
# 交叉编译KIDR路径:
KDIR := /home/zrz/Project/phytium-pi-os/output/build/linux-custom
KDIR := /home/zrz/Project/phytium-pi-os/output/target/usr/src/linux-headers-5.10.153-phytium-embeded-v2.0
endif

# 系统内编译：
all:
	make -C $(KDIR) M=$(PWD) modules

# The following lines are considered as comments because the condition is always false
ifeq (0,1)
	# 交叉编译：手动下载配置交叉工具链：
	make -C $(KDIR) M=$(PWD) modules \
		CROSS_COMPILE=aarch64-none-linux-gnu- \
		ARCH=arm64
	# 交叉编译：利用编译内核时给出的工具链环境：
	make -C $(KDIR) M=$(PWD) modules \
		CROSS_COMPILE=/home/xxx/phytium-pi-os/output/host/bin/aarch64-none-linux-gnu- \
		ARCH=arm64
endif

clean:
	make -C $(KDIR) M=$(PWD) clean
```



## 编写内核模块

参考 [2.1-理论-Linux驱动基础.pdf](.assets/2.1-理论-Linux驱动基础.pdf) **第三章：《Linux 内核模块编程》**

以下给出内核模块的内容：

```c
#include <linux/init.h>
#include <linux/module.h>
static int test_init(void)
{
printk("hello world\n");
return 0;
}
static void test_exit(void)
{
printk("bye\n");
}
module_init(test_init);
module_exit(test_exit);
MODULE_LICENSE("GPL");
```



## 测试生成的`hello.ko`文件：

- 在使用此内核生成的OS内加载模块：

  ```shell
  sudo insmod test.ko
  ```

  ![image-20240122224108576](./%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BC%96%E7%A8%8B.assets/image-20240122224108576.png)

- 查看内核日志：

  ```shell
  dmesg
  ```

  ![image-20240122224235397](./%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BC%96%E7%A8%8B.assets/image-20240122224235397.png)

- 卸载模块：

  ```shell
  sudo rmmod hello
  ```

  ![image-20240122224321515](./%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BC%96%E7%A8%8B.assets/image-20240122224321515.png)
  
  





